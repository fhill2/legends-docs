## Backend { style="page-break-before:always;"}

### API

The API is implemented in the server module, which is responsible for all communication between the client and the server. The API endpoints are all accessed by an HTTP GET request with a URL that begins with '/api/'. The first two endpoints are '/api/champions/:champion' and '/api/items/:item'; these retrieve the data for a single champion or item respectively. The final part of the URL is replaced with the name of a champion or item. If the server has data on a champion/item with that name, it returns that data. Otherwise, the appropriate HTTP error is sent (404, since the requested data does not exist).

The '/api/scenario/:scenario' endpoint is different from the other two. It receives a base 64 encoded string as the final part of the URL, which is interpreted in util.mjs. This base 64 string contains a serialized version of 2 BuildConfig objects. They are serialized by replacing the champion/item data with the index of that champion/item in the master list (produced from the JSON files on the server). This is done to keep the base 64 string as small as possible (it only encodes 24 bytes of data). If the base 64 is malformed in any way, a 400 HTTP error is sent (invalid request).

There are two more endpoints available that are not a part of the API. One of them produces a random, valid scenario for testing purposes. The other one ('/:b64') currently takes a base 64 string of the same form as the scenario api endpoint and returns the decoded form as JSON. This was planned to be turned into another way users could access the site, using the scenario encoded into the URL to produce a default configuration (and associated evaluation). This would allow users to share configurations and builds with each other much more easily; this is why it was especially important to keep the base 64 strings as short as possible to support share-ability.

### Damage Calculations

There are many different properties that each champion has, which may be influenced by any number of sources. The same can be said of items and abilities as well, and all of these can effect each other in any order. Before even attempting to determine these effects, we needed to introduce some degree of consistency to the information that we have. Many of the properties that champions have may have multiple names (e.g. 'health' could be 'hp', 'max hp', etc. with varying capitalization across our sources). To ensure we only used one of these many names for each distinct property, several enums (actually const objects, since javascript doesn't have enums) were made to list all of these properties in a single canonical form. This also allowed these properties to be iterated over, keeping the code at a somewhat manageable volume. More complex entities were given classes so as to give us a known way of interacting with them. Instances of these objects are stored globally, since they represent only the information known prior to any configuration or calculation. These objects are constructed in data.mjs, where the input data is parsed and put into a guaranteed form. Custom ability implementations are also added at this stage, by searching abilities.mjs and replacing any components of the Ability objects that are found there.

The method for calculating the output of each ability of each champion went through several redesigns. Hypothetically, the ultimate goal of this software would necessarily be to cover all champions and all determinable effects from those champion's abilities. So, each model was designed to be extensible to all champions, rather than just the few we are able to produce in our MVP. The first model centered around passing a list of player properties to each effector in sequence, allowing them to perform whatever influence needed independently. This works well for item effects, but it does not work when calculating the output of abilities. This is because abilities often scale with an unexpected trait, or only the value of a trait at a specific point in the calculation. This information could not be retrieved from only the total of each effect. Instead, a calculate-on-retrieval model is used that allows for any property to be retrieved, which may in turn be dependent on any other property. Since most abilities have some sort of unique calculation or effect to them, we were forced to move away from a one-size-fits all model and use some degree of custom code for each champion. The calculate-on-get model greatly reduces the redundancy and complexity of this custom code, making it feasible to implement custom code for each champion.

The damage calculations are done in both abilities.mjs and formulas.mjs. Formulas.mjs provides an evaluate_scenario function which performs calculations on a given scenario and returns relevant results. These results are what the server will send to the client as JSON for presentation. This module also provides the BuildState class, which tracks and calculates various statistics of a particular player, with a given opposing player in mind. This class is implemented here instead of in types.mjs because it is primarily a functional interface for producing player stats, as opposed to the classes in types.mjs, which are primarily data containers. BuildState is where properties of the champion are calculated. The BuildState retrieves the effects of items and abilities on the requested trait and produces the final result only when that particular trait is needed. This allows traits to be calculated in an arbitrary and unknown order, allowing the problem to be broken into smaller, more easily implemented pieces. These 'pieces' are the aforementioned custom code required for each champion. This is found within abilities.mjs, as well as the GenericAbility class. This is an implementation of an ability that is almost never sufficient on its own, but rather uses the most common methods for each calculation. This allows us to manually implement only the components that deviate from this generic form. These abilities can also make use of several useful functions found in formulas.mjs, such as apply_armor, helping to mitigate the redundancy of each implementation.
